/* Created by: Peter
 *
 * History:
 *   2015-07-29 Malte
 *     Fails in Silicon-QP (b644a5e28e71) in 9s: Loop invariant may not be preserved
 */

method swap(a: Array, i: Int, j: Int)
  requires acc(loc(a,i).val) && acc(loc(a,j).val);
  ensures acc(loc(a,i).val) && acc(loc(a,j).val);
  ensures loc(a,i).val == old(loc(a,j).val);
  ensures loc(a,j).val == old(loc(a,i).val);
{
  var t: Bool;
  t := loc(a,i).val;
  loc(a,i).val := loc(a,j).val;
  loc(a,j).val := t
}

function lte(b1: Bool, b2: Bool): Bool {
  !b1 || b2
}

function countFalse(a: Array, from: Int, to: Int): Int
  requires 0 <= from && from <= to && to <= length(a);
  requires forall z: Int :: (from <= z && z < to ==> acc(loc(a,z).val));
{
  (from == to ? 0 : (loc(a,from).val ? 0 : 1) + countFalse(a, from+1, to))
}


method two_way_sort(a: Array)
  requires forall z: Int :: (0 <= z && z < length(a) ==> acc(loc(a,z).val));
  ensures forall z: Int :: (0 <= z && z < length(a) ==> acc(loc(a,z).val));
{
  var i: Int
  i := 0;
  var j : Int;
  j := length(a) - 1;
  while (i <= j)
    invariant 0 <= i && i <= j + 1 && j < length(a);
    invariant forall z: Int :: (0 <= z && z < length(a) ==> acc(loc(a,z).val));
    invariant forall z: Int :: (0 <= z && z < i ==> !loc(a,z).val);
    invariant forall z: Int :: (j < z && z < length(a) ==> loc(a,z).val);
    invariant countFalse(a,0,i) + countFalse(a,i,j+1) + countFalse(a,j+1,length(a)) == old(countFalse(a,0,length(a)));
  {
    var measure: Int;     // encode termination
    measure := j - i;
    assert 0 <= measure;  // measure is a natural number

    if (!loc(a,i).val) {
      i := i+1;
    } else {
      if (loc(a,j).val) {
        j := j-1;
      } else {
        swap(a, i, j);
        i := i+1;
        j := j-1;
     }
    }

    assert j - i < measure;  // check termination measure
  }
}


field val: Bool;

domain Array {
  function loc(a: Array, i: Int): Ref
  function length(a: Array): Int
  function first(r: Ref): Array
  function second(r: Ref): Int

  axiom all_diff {
    forall a: Array, i: Int :: {loc(a, i)}
      first(loc(a, i)) == a && second(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: Array :: length(a) >= 0
  }
}
