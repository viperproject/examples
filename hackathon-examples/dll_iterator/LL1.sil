/////////////////////////////////////////////////////////////////////
//This is a simple singly linked list

/////////////////////////////////////////////////////////////////////
//LinkedListNode

field LLN_val : Int
field LLN_next : Ref

predicate LLN(this : Ref) 
{
	acc(this.LLN_val) && 
	acc(this.LLN_next) && (this.LLN_next!=null ==> acc(LLN(this.LLN_next),write))
}

function LLN_aVal(this : Ref) : Seq[Int]
	requires this!=null && acc(LLN(this),write)
{
	unfolding acc(LLN(this),write) in (this.LLN_next == null ) ? Seq(this.LLN_val) :  Seq(this.LLN_val) ++ LLN_aVal(this.LLN_next)
}

/////////////////////////////////////////////////////////////////////
//LinkedList
field LL_head : Ref

predicate LL(this : Ref)
{
	acc(this.LL_head) && 
	(this.LL_head!=null ==> acc(LLN(this.LL_head),write))
}

function LL_aVal(this : Ref) : Seq[Int]
	requires this!=null && acc(LL(this),write)
{
	unfolding acc(LL(this),write) in (this.LL_head==null) ? Seq[Int]() : LLN_aVal(this.LL_head)
}

method LL_make() returns (r:Ref)
	ensures r!=null
	ensures acc(LL(r),write)
{
	r := new(LL_head)
	r.LL_head:=null
	fold LL(r)
}

method LL_prepend(this : Ref,x : Int) 
	requires this!=null
	requires acc(LL(this),write)
	ensures acc(LL(this),write)
	ensures LL_aVal(this) == Seq(x) ++ old(LL_aVal(this))
{
	var n : Ref
	n := new(LLN_val,LLN_next)
	n.LLN_val := x

	unfold LL(this)
	n.LLN_next := this.LL_head
	fold LLN(n)
	this.LL_head := n
	fold LL(this)
}
