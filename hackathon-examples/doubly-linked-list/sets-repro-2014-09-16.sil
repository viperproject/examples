/* Created by: Peter
 *
 * History:
 *   2015-07-29 Malte
 *     Silicon (d07b47260c32) didn't terminate in a few minutes.
 *     Z3 consumed lots of memory.
 *     Haven't looked into it yet.
 *   2014-09-16 Malte
 *     Added initial snapshot sent by Peter
 */

// class LinkedList
field header: Ref
field nodes: Set[Ref]
field size: Int

predicate Valid(this: Ref) {
  acc(this.header) && acc(this.nodes) && acc(this.size) &&
  this.header in this.nodes &&
  (forall n:Ref :: n in (this.nodes) ==> acc(n.next)) &&
  (forall n:Ref :: n in (this.nodes) ==> acc(n.prev)) &&
  (forall n:Ref :: n in (this.nodes) ==> acc(n.value)) &&
  (forall n:Ref :: n in (this.nodes) ==> n.next != null && n.next in this.nodes) &&
  (forall n:Ref :: n in (this.nodes) ==> n.prev != null && n.prev in this.nodes) &&
  (forall n:Ref :: n in (this.nodes) ==> n.next.prev == n) &&
  (forall n:Ref :: n in (this.nodes) ==> n.prev.next == n)
}

// ISSUE: Silicon does not check function termination
function Nodes(first: Ref, last: Ref, ns: Set[Ref]): Seq[Ref]
  requires first in ns;
  requires (forall n:Ref :: n in ns ==> acc(n.next));
  requires (forall n:Ref :: n in ns ==> acc(n.value));
  requires (forall n:Ref :: n in ns ==> n.next != null && n.next in ns);
  ensures (forall i: Int :: i in [0..|result|) ==> result[i] in ns);
{
  (first == last) ? Seq[Ref]() : Seq(first) ++ Nodes(first.next, last, ns)
}

function Nodes2Values(ns: Seq[Ref]): Seq[Ref]
  requires (forall i: Int :: i in [0..|ns|) ==> acc(ns[i].value))
{
  |ns| == 0 ? Seq[Ref]() : Seq(ns[0].value) ++ Nodes2Values(ns[1..])
}

function NodeValues2(first: Ref, last: Ref, ns: Set[Ref]): Seq[Ref]
  requires first in ns;
  requires (forall n:Ref :: n in ns ==> acc(n.next));
  requires (forall n:Ref :: n in ns ==> acc(n.value));
  requires (forall n:Ref :: n in ns ==> n.next != null && n.next in ns);
{
  Nodes2Values(Nodes(first, last, ns))
}

function NodeValues(first: Ref, last: Ref, ns: Set[Ref]): Seq[Ref]
  requires first in ns;
  requires (forall n:Ref :: n in ns ==> acc(n.next));
  requires (forall n:Ref :: n in ns ==> acc(n.value));
  requires (forall n:Ref :: n in ns ==> n.next != null && n.next in ns);
{
  (first == last) ? Seq[Ref]() : Seq(first.value) ++ NodeValues(first.next, last, ns)
}

function Values(this: Ref): Seq[Ref]
  requires this != null && acc(Valid(this));
{
  unfolding Valid(this) in NodeValues(this.header.next, this.header, this.nodes)
}






// class Node
field next: Ref
field prev: Ref
field value: Ref

