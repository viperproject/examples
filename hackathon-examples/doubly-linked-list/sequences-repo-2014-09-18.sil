/* Created by: Peter
 *
 * History:
 *   2015-07-29 Malte
 *     Silicon (d07b47260c32) didn't terminate in a few minutes.
 *     Haven't looked into it yet.
 *   2015-03-12 Malte
 *     Verified in about 25s
 */

// class DList
field header: Ref
/*ghost*/ field nodes: Seq[Ref]

define ValidBody(this) (
  acc(this.header) && acc(this.nodes) && this.header in this.nodes &&
  !(null in this.nodes) &&
  0 < |this.nodes| &&
  this.header == this.nodes[0] &&
  (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].next)) &&
  (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].prev)) &&
  (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].value)) &&
  /* [2015-03-10 Malte] I pulled out the first conjunct because it had an
   * unexpected effect on the triggers generated for the forall: With the
   * conjunct, the computed trigger sets are stricter then those computed
   * for the quantifier without the first conjunct. The stricter triggers
   * prevent Z3 from showing, at the beginning of addBefore, that
   * n.prev in this.nodes, which is in turn necessary to show that
   * n.prev != null.
   */
  (forall i: Int :: i in [0..|this.nodes|) ==>
    // !(this.nodes[i] in this.nodes[i+1..]) &&
    (i + 1 < |this.nodes| ==> this.nodes[i].next == this.nodes[i+1]) &&
    (0 < i ==> this.nodes[i].prev == this.nodes[i-1]) &&
    this.nodes[0].prev == this.nodes[|this.nodes|-1] &&
    this.nodes[|this.nodes|-1].next == this.nodes[0]
  ) &&
  (forall i: Int :: i in [0..|this.nodes|) ==> !(this.nodes[i] in this.nodes[i+1..]))
)

predicate Valid(this: Ref) { ValidBody(this) }

method indexOf(this: Ref, e: Int) returns (index: Int, rd: Perm)
  requires this != null && acc(Valid(this));
  ensures acc(Valid(this));
{
  index := 0;
  var ptr: Ref;
  unfold acc(Valid(this));
  ptr := this.header;
  ptr := ptr.next;

  var continue: Bool;
  continue := true;

  while(ptr != this.header && continue)
    invariant ValidBody(this)
    invariant ptr in this.nodes;
  {
    if(ptr.value == e) {
      continue := false;
    }
    index := index + 1;
    ptr := ptr.next;
  }
  if(continue) {
    index := -1;
  }
  fold acc(Valid(this));
}


method addBefore(this: Ref, i: Int, n: Ref)
  requires acc(Valid(this));
  requires unfolding Valid(this) in (n in this.nodes);
  ensures acc(Valid(this));
{
  var newNode: Ref;
  newNode := new(*);
  newNode.value := i;
  newNode.next := n;
  unfold Valid(this);
  newNode.prev := n.prev;
  newNode.prev.next := newNode;
  newNode.next.prev := newNode;

  // this ghost assignment picks the index of n (it exists because of the second precondition
  var index: Int;
  assume 0 <= index && index < |this.nodes| && this.nodes[index] == n;

  if(index == 0) {
    this.nodes := this.nodes ++ Seq(newNode);
  } else {
    this.nodes := this.nodes[..index] ++ Seq(newNode) ++ this.nodes[index..];
  }

  fold Valid(this);
}



// class Node
field next: Ref
field prev: Ref
field value: Int

