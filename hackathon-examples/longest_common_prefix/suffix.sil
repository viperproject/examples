/* Unfinished version of Longest Common Prefix problem from
 *   VerifyThis@FM2012: http://fm2012.verifythis.org/challenges
 *
 * [2016-01-11 Malte]
 *   Finished the first task of the challenge
 *   Started working on the "advanced" section of the challenge. The specs are already
 *   quite substantial, but definitely not complete.
 *   The example takes forever to verify (300-400 seconds) ...
 *
 * [2016-??-?? Caterina?]
 *   Nearly finished the first task of the challenge (unfinished due to some problem
 *   in Silicon)
 */

define access(a) forall k: Int :: 0 <= k && k < len(a) ==> acc(loc(a, k).val)
define untouched(a) forall k: Int :: 0 <= k && k < len(a) ==> loc(a, k).val == old(loc(a, k).val)

/* Task A */

method lcp(a: IArray, x: Int, y: Int) returns (n: Int)
  requires access(a)
  requires 0 <= x && 0 <= y && x < len(a) && y < len(a)
  ensures  access(a)
  ensures  0 <= n && x + n <= len(a) && y + n <= len(a)
  ensures  forall k: Int :: x <= k && k < x + n ==> loc(a, k).val == loc(a, y + k - x).val
  /* The following postcondition is logically equivalent to the previous one, and a bit
   * easier to understand. However, it can currently not be used because it contains
   * no possible triggers (due to the arithmetic operations inside the loc-expressions).
   */
  // ensures  forall k: Int :: 0 <= k && k < n ==> loc(a, x + k).val == loc(a, y + k).val
  ensures  x + n < len(a) && y + n < len(a) ==> loc(a, x + n).val != loc(a, y + n).val
{
   n := 0
   while (x + n < len(a) &&  y + n < len(a) && loc(a, x + n).val == loc(a, y + n).val)
     invariant n >= 0
     invariant access(a)
     invariant x + n <= len(a) && y + n <= len(a)
     invariant forall k: Int :: x <= k && k < x + n ==> loc(a, k).val == loc(a, y + k - x).val
   {
     n := n + 1
   }
}

// a[i] := 1
// loc(a, i).val := 1

// a[i] == 1
// loc(a, i).val == 1

// function f_lcp(a: IArray, x: Int, y: Int): Int
//   requires access(a)
//   //requires forall i: Int :: 0<=i && i<len(a) ==> acc(loc(a, i).val)
//   requires x >= 0 && y >= 0 && x < len(a) && y < len(a)
//   ensures result>=0 && x+result <= len(a) && y+result <= len(a)
//   ensures forall k:Int :: x<=k && k < x+result ==> loc(a,k).val == loc(a,y+k-x).val
//   ensures (x+result < len(a) && y+result < len(a) ==> loc(a,x+result).val != loc(a,y+result).val)
//   {
//     0
//   }

/* Task B (advanced) */

method SuffixArray_create(a: IArray) returns (suffixes: IArray)
  requires access(a)
  ensures  access(a) && untouched(a)
  ensures  access(suffixes)
  ensures  len(suffixes) == len(a)
{
  var N: Int := len(a)

  // suffixes = new int[N]
  inhale len(suffixes) == N
  inhale access(suffixes)

  var i: Int := 0

  while (i < N)
    invariant 0 <= i && i <= N
    invariant access(suffixes)
    invariant forall j: Int :: 0 <= j && j < i ==> loc(suffixes, j).val == j
  {
    loc(suffixes, i).val := i
    i := i + 1
  }
}

/* Returns
 *    0 iff x == y
 *   -1 iff a[x..] lex-lteq a[y..]
 *    1 iff a[y..] lex-lt a[x..]
 * That is, 1 is returned iff a[y..] must be ordered before a[x..]
 *
 */
method SuffixArray_compare(a: IArray, x: Int, y: Int) returns (l: Int, c: Int)
  requires access(a)
  requires 0 <= x && 0 <= y && x < len(a) && y < len(a)
  ensures  access(a) && untouched(a)
  ensures  0 <= l && x + l <= len(a) && y + l <= len(a)
  ensures  forall k: Int :: x <= k && k < x + l ==> loc(a, k).val == loc(a, y + k - x).val
  ensures  -1 <= c && c <= 1
  ensures  c == 0  <==> x == y
  ensures  c == -1 <==> (x + l == len(a) || y + l < len(a) && loc(a, x + l).val < loc(a, y + l).val)
  ensures  c ==  1 <==> (y + l == len(a) || x + l < len(a) && loc(a, x + l).val > loc(a, y + l).val)
  /**/
  ensures [c == 0  <==> suffix_eq(suffix(a, x), suffix(a, y)), true]
  ensures [c == -1 <==> suffix_lteq(suffix(a, x), suffix(a, y)), true]
  ensures [c ==  1 <==> suffix_lt(suffix(a, y), suffix(a, x)), true]
{
  if (x == y) {
    c := 0
    l := 0
  } else {
    var N: Int := len(a)
    l := 0

    while (x + l < N && y + l < N && loc(a, x + l).val == loc(a, y + l).val)
      invariant 0 <= l
      invariant access(a) && untouched(a)
      invariant x + l <= N && y + l <= N
      invariant forall k: Int :: x <= k && k < x + l ==> loc(a, k).val == loc(a, y + k - x).val
    {
      l := l + 1
    }

    if (x + l == N) { c := -1 }
    elseif (y + l == N) { c := 1 }
    elseif (loc(a, x + l).val < loc(a, y + l).val) { c := -1 }
    elseif (loc(a, x + l).val > loc(a, y + l).val) { c := 1 }
    else {
      // throw new RuntimeException()
      assert false
    }
  }
}

function suffix(a: IArray, start: Int): Seq[Int]
  //requires access(a)
    /* TODO: Increases the verification time significantly! */
  requires 0 <= start && start < len(a)
  ensures  |result| == len(a) - start
  //ensures  forall k: Int :: 0 <= k && k < |result| ==> result[k] == loc(a, k+start).val
      /* TODO: The lookup axiom(s) for loc(a, k+start).val generated by Silicon
       *       lack a trigger because lookup(fvf, loc(a, k+start)) cannot be used as
       *       a trigger (due to the arithmetic operation).
       */

function suffix_eq(suffix1: Seq[Int], suffix2: Seq[Int]): Bool
function suffix_lt(suffix1: Seq[Int], suffix2: Seq[Int]): Bool

function suffix_lteq(suffix1: Seq[Int], suffix2: Seq[Int]): Bool {
  suffix_lt(suffix1, suffix2) || suffix_eq(suffix1, suffix2)
}

define sfx(k) suffix(a, loc(data, k).val)

method SuffixArray_sort(a: IArray, data /*suffixes*/: IArray)
  requires access(a)
  requires access(data)
  requires len(a) == len(data)
  requires forall k: Int :: 0 <= k && k < len(data) ==> 0 <= loc(data, k).val && loc(data, k).val < len(data)
  ensures  access(a) && untouched(a)
  ensures  access(data)
  ensures  forall k: Int :: 0 <= k && k < len(data) ==> 0 <= loc(data, k).val && loc(data, k).val < len(data)
  ensures  forall k: Int :: 0 <= k && k < len(data) - 1 ==> suffix_lteq(sfx(k), sfx(k + 1))
  /* TODO: ensure that 'data' has been permuted*/
{
  var i: Int := 0
  var j: Int
  var l: Int
  var c: Int

  while (i < len(data))
    invariant 0 <= i && i <= len(data)
    invariant access(a) && untouched(a)
    invariant access(data)
    invariant forall k: Int :: 0 <= k && k < len(data) ==> 0 <= loc(data, k).val && loc(data, k).val < len(data)
    invariant forall k: Int :: 0 <= k && k < i - 1 ==> suffix_lteq(sfx(k), sfx(k + 1))
  {
    j := i

    /* We cannot use compare in the loop invariant since it is not an expression */

    if (0 < j) {
      l, c := SuffixArray_compare(a, loc(data, j - 1).val, loc(data, j).val)
    }

if (0 < j && 0 < c) {
  /* TODO: If 'c == -1' is assumed before the while, wrapping the latter in the if
   *       still gain performance. It might help if Silicon checked, before executing
   *       a loop, if the corresponding loop guard is satisfiable.
   */
    while (0 < j && 0 < c)
      invariant 0 <= j && j <= i
      invariant access(a) && untouched(a)
      invariant access(data)
      invariant forall k: Int :: 0 <= k && k < len(data) ==> 0 <= loc(data, k).val && loc(data, k).val < len(data)

      invariant forall k: Int :: 0 <= k && k < j - 1 ==> suffix_lteq(sfx(k), sfx(k + 1))
      invariant 0 <= j - 1 && j + 1 < i ==> suffix_lteq(sfx(j - 1), sfx(j + 1))
      invariant j + 1 < i ==> suffix_lteq(sfx(j), sfx(j + 1))
      invariant forall k: Int :: j + 1 <= k && k < i - 1 ==> suffix_lteq(sfx(k), sfx(k + 1))
      invariant j < i ==> suffix_lteq(sfx(i-1), sfx(i))

      invariant 0 <= j - 1 && 0 < c  ==> suffix_lt(sfx(j), sfx(j - 1))
      invariant 0 <= j - 1 && c <= 0 ==> suffix_lteq(sfx(j - 1), sfx(j))
    {
      if (j == i-1) {
        assert suffix_lt(sfx(i-1), sfx(i-2)) // i-2 <= i-1
        assert suffix_lteq(sfx(i-1), sfx(i)) // i-1 <= i
        assume suffix_lteq(sfx(i-2), sfx(i)) // i-2 <= i // TODO: Axiomatise transitivity if lt/lteq
      }


      var b: Int := j - 1
      var t: Int := loc(data, j).val
      loc(data, j).val := loc(data, b).val
      loc(data, b).val := t

      j := j - 1

      if (0 < j ) {
        l, c := SuffixArray_compare(a, loc(data, j - 1).val, loc(data, j).val)
      }
    }
} // IF

    i := i + 1
  }
}

// define string Seq[Int]

// domain string {

// }


/* Encoding of arrays */

field val: Int

domain IArray {
  function loc(a: IArray, i: Int): Ref
  function len(a: IArray): Int
  function first(r: Ref): IArray
  function second(r: Ref): Int

  axiom all_diff {
    forall a: IArray, i: Int :: {loc(a, i)}
      first(loc(a, i)) == a && second(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: IArray :: len(a) >= 0
  }
}
