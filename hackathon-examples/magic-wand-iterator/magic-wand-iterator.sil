// ListIterator fields
field iteratee: Ref
field current: Ref
field last: Ref
// List fields
field sentinel: Ref
// Node fields
field next: Ref
field prev: Ref
field val: Int
define NODE_FIELDS(x) acc(x.next) && acc(x.prev) && acc(x.val)
// Node class
predicate state(n: Ref) {
  NODE_FIELDS(n) && (n.next != null ==> acc(state(n.next)) && get_prev(n.next) == n)
}

function get_prev(n: Ref) : Ref
  requires acc(state(n))
  {
    unfolding state(n) in n.prev
  }

// List class
predicate list(l: Ref) {
  acc(l.sentinel) && acc(state(l.sentinel)) && get_prev(l.sentinel) == null
}

// ListIterator class
predicate ready(i:Ref) {
  acc(i.iteratee,2/3) && acc(i.iteratee.sentinel) && acc(i.current) && NODE_FIELDS(i.current) && acc(i.last) && i.current.prev == i.last &&
  (i.current.next != null ==> acc(state(i.current.next)) && get_prev(i.current.next) == i.current) && (let cur == (i.current) in let sent == (i.iteratee.sentinel) in let lst == (i.last) in (acc(state(cur)) && get_prev(cur) == lst --* acc(state(sent)) && get_prev(sent) == null))
}

predicate readyForNext(i:Ref) {
  acc(i.iteratee,2/3) && acc(i.iteratee.sentinel) && acc(i.current) && NODE_FIELDS(i.current) && acc(i.last) && i.current.prev == i.last &&
  i.current.next != null && acc(state(i.current.next)) && get_prev(i.current.next) == i.current && (let cur == (i.current) in let sent == (i.iteratee.sentinel) in let lst == (i.last) in (acc(state(cur)) && get_prev(cur) == lst --* acc(state(sent)) && get_prev(sent) == null))
}

predicate readyForRemove(i:Ref) {
  acc(i.iteratee,2/3) && acc(i.iteratee.sentinel) && acc(i.last) && acc(i.last.next) && acc(i.current) && (i.current != null ==> NODE_FIELDS(i.current) && i.current.prev == i.last && i.last.next == i.current &&
  (i.current.next != null ==> acc(state(i.current.next)) && get_prev(i.current.next) == i.current)) && (let lst == (i.last) in let sent == (i.iteratee.sentinel) in (acc(lst.next) && (lst.next != null ==> acc(state(lst.next)) && get_prev(lst.next) == lst) --* acc(state(sent)) && get_prev(sent) == null))
}

method ListIterator_hasNext(this : Ref) returns (res : Bool)
  requires acc(ready(this))
  ensures res ==> acc(readyForNext(this))
  ensures !res ==> acc(ready(this))
{
  unfold ready(this)
  if (this.current.next == null) {
    fold ready(this)
    res := false
  } else {
    fold readyForNext(this)
    res := true
  }
}

method ListIterator_new(l : Ref) returns (this : Ref)
  requires l != null && acc(list(l))
  ensures acc(ready(this)) && (acc(ready(this)) --* acc(list(l)))
  {
    var cur : Ref
    var sent : Ref
    var lst : Ref
    this := new(iteratee,current,last) // ListIterator
    this.iteratee := l
    unfold list(l)
    this.current := l.sentinel
    this.last := null
    cur := this.current
    sent := this.iteratee.sentinel
    lst := this.last
    package (acc(state(cur)) && get_prev(cur) == lst --* acc(state(sent)) && get_prev(sent) == null)
    unfold state(l.sentinel)
    fold ready(this)
    // need to check whether these specific fractions are really necessary
    package (acc(this.iteratee,1/3) && acc(list(this.iteratee)) --* acc(this.iteratee,2/3) && l == this.iteratee && acc(list(l)))
    wand w := (acc(this.iteratee,1/3) && acc(list(this.iteratee)) --* acc(this.iteratee,2/3) && l == this.iteratee && acc(list(l)))

    package (acc(ready(this)) --* unfolding ready(this) in folding state(this.current) in let cr == (this.current) in let st == (this.iteratee.sentinel) in let lt == (this.last) in applying (acc(state(cr)) && get_prev(cr)==lt --* acc(state(st)) && get_prev(st) == null) in folding acc(list(this.iteratee)) in applying w in acc(list(l)))
  }


method ListIterator_next(this: Ref) returns (v : Int)
  requires acc(readyForNext(this))
  ensures acc(readyForRemove(this)) && (acc(readyForRemove(this)) --* acc(ready(this)))
  {
    var cur : Ref
    var lst : Ref
    var sent : Ref
    unfold readyForNext(this)
    cur := this.current
    lst := this.last
    sent := this.iteratee.sentinel

    wand w := (acc(state(cur)) && get_prev(cur) == lst --* acc(state(sent)) && get_prev(sent) == null)
    unfold state(this.current.next)
    this.last := this.current
    this.current := this.current.next
    cur := this.current
    lst := this.last
    sent := this.iteratee.sentinel

    package acc(lst.next) && (lst.next != null ==> acc(state(lst.next)) && get_prev(lst.next) == lst) --* folding state(lst) in applying w in acc(state(sent)) && get_prev(sent) == null
    fold readyForRemove(this)



    package acc(readyForRemove(this)) --* unfolding readyForRemove(this) in
      (let lt == (this.last) in let st == (this.iteratee.sentinel) in
        packaging
          acc(lt.next,1/2) && (lt.next != null ==> NODE_FIELDS(lt.next) && (lt.next.next != null ==> acc(state(lt.next.next)) && get_prev(lt.next.next) == lt.next)) --* (acc(lt.next,1/2) && (lt.next != null ==> state(lt.next))) in
//        folding acc(state(lt.next)) in
   acc(this.last) // PROBLEM : the folding only makes sense if lt.next (i.e. this.last.next) != null...
  //      acc(lt.next) && (lt.next != null ==> acc(state(lt.next)) && get_prev(lt.next) == lt)
      //applying (acc(lt.next) && (lt.next != null ==> acc(state(lt.next)) && get_prev(lt.next) == lt) --* acc(state(st)) && get_prev(st) == null) in
     //   acc(state(st)) && get_prev(st) == null
      )
    }