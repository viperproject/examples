// class DList
field header: Ref
/*ghost*/ field nodes: Seq[Ref]

predicate Valid(this: Ref) {
  acc(this.header) && acc(this.nodes) && this.header in this.nodes &&
  !(null in this.nodes) &&
  0 < |this.nodes| &&
  this.header == this.nodes[0] &&
  (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].next)) &&
  (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].prev)) &&
  (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].value)) &&
  (forall i: Int :: i in [0..|this.nodes|) ==>
    !(this.nodes[i] in this.nodes[i+1..]) &&
    (i + 1 < |this.nodes| ==> this.nodes[i].next == this.nodes[i+1]) &&
    (0 < i ==> this.nodes[i].prev == this.nodes[i-1]) &&
    this.nodes[0].prev == this.nodes[|this.nodes|-1] &&
    this.nodes[|this.nodes|-1].next == this.nodes[0]
  )
}


method indexOf(this: Ref, e: Int) returns (index: Int, rd: Perm)
  requires this != null && acc(Valid(this));
  ensures acc(Valid(this));
{
  index := 0;
  var ptr: Ref;
  unfold acc(Valid(this));
  ptr := this.header;
  ptr := ptr.next;

  var continue: Bool;
  continue := true;

  while(ptr != this.header && continue)
    invariant acc(this.header) && acc(this.nodes) && this.header in this.nodes;
    invariant !(null in this.nodes);
    invariant 0 < |this.nodes|;
    invariant this.header == this.nodes[0];
    invariant (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].next));
    invariant (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].prev));
    invariant (forall i: Int :: i in [0..|this.nodes|) ==> acc(this.nodes[i].value));
    invariant (forall i: Int :: i in [0..|this.nodes|) ==>
                !(this.nodes[i] in this.nodes[i+1..]) &&
                (i + 1 < |this.nodes| ==> this.nodes[i].next == this.nodes[i+1]) &&
                (0 < i ==> this.nodes[i].prev == this.nodes[i-1]) &&
                this.nodes[0].prev == this.nodes[|this.nodes|-1] &&
                this.nodes[|this.nodes|-1].next == this.nodes[0]
              );
    invariant ptr in this.nodes;
  {
    if(ptr.value == e) {
      continue := false;
    }
    index := index + 1;
    ptr := ptr.next;
  }
  if(continue) {
    index := -1;
  }
  fold acc(Valid(this));
}


method addBefore(this: Ref, i: Int, n: Ref)
  requires acc(Valid(this));
  requires unfolding Valid(this) in (n in this.nodes);
  ensures acc(Valid(this));
{
  var newNode: Ref;
  newNode := new(*);
  newNode.value := i;
  newNode.next := n;
  unfold Valid(this);
  newNode.prev := n.prev;
  newNode.prev.next := newNode;
  newNode.next.prev := newNode;

  // this ghost assignment picks the index of n (it exists because of the second precondition
  var index: Int;
  assume 0 <= index && index < |this.nodes| && this.nodes[index] == n;

  if(index == 0) {
    this.nodes := this.nodes ++ Seq(newNode);
  } else {
    this.nodes := this.nodes[..index] ++ Seq(newNode) ++ this.nodes[index..];
  }

  fold Valid(this);
}



// class Node
field next: Ref
field prev: Ref
field value: Int

