    field val: Int

domain IArray {
  function loc(a: IArray, i: Int): Ref
  function length(a: IArray): Int
  
  axiom all_diff {
    forall a1: IArray, a2: IArray, i: Int, j: Int :: {loc(a1, i), loc(a2, j)}
      (a1 != a2 || i != j) ==> loc(a1, i) != loc(a2, j)
  }
  
  axiom length_nonneg {
    forall a: IArray :: length(a) >= 0
  }
}


method max(a: IArray) returns (x:Int)
  requires forall i: Int :: 0 <= i && i<length(a) ==> acc(loc(a, i).val)
  requires length(a) > 0
  ensures forall i: Int :: 0 <= i && i<length(a) ==> acc(loc(a, i).val)
  ensures 0 <= x && x < length(a)
  ensures forall i: Int :: 0 <= i && i<length(a) ==> loc(a, i).val <= loc(a,x).val
  {
        var y: Int
        x := 0;
        y := length(a)-1;

        while (x != y) 
          invariant forall i: Int :: 0 <=i && i < length(a) ==> acc(loc(a, i).val)
          invariant 0 <= x && x <= y && y < length(a)
          invariant (forall i: Int :: ((0 <= i && i<x) || (y < i && i<length(a))) ==> loc(a,i).val < loc(a,x).val) || (forall i: Int :: ((0 <= i && i<x) || (y < i && i<length(a))) ==> loc(a,i).val <= loc(a,y).val)
        {
            if (loc(a,x).val <= loc(a,y).val) {
              x := x+1
            }
            else {
              y := y-1
            }
        }
  }