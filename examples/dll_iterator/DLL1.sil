/////////////////////////////////////////////////////////////////////
//LinkedListNode

field DLLN_val : Int
field DLLN_next : Ref
field DLLN_prev : Ref

predicate DLLSEG(start : Ref, end:Ref)
{
	start!=end ==> (
		acc(start.DLLN_val) && 
		acc(start.DLLN_next) && 
		acc(start.DLLN_prev) && 
		(start.DLLN_next==null ==> end == null) &&
		(
			start.DLLN_next!=null ==> (
				acc(DLLSEG(start.DLLN_next,end),write) &&
				(start.DLLN_next!=end ==> DLLSEG_prev(start.DLLN_next,end) == start)
			)
		)
	)
}

function DLLSEG_aVal(start : Ref,end:Ref) : Seq[Int]
	requires start!=null 
	requires acc(DLLSEG(start,end),wildcard)
	ensures start!=end ==> |result|>0
	ensures start==end ==> result == Seq[Int]()
{
	(start == end) ? Seq[Int]() :
	unfolding acc(DLLSEG(start,end),wildcard) in 
		Seq(start.DLLN_val) ++ ( (start.DLLN_next == null ) ?  Seq[Int]() :  DLLSEG_aVal(start.DLLN_next,end) )
}

function DLLSEG_last(start : Ref,end:Ref) : Ref
	requires start!=null
	requires start!=end
	requires acc(DLLSEG(start,end),wildcard)
	ensures result != null
//	ensures |DLLSEG_aVal(start,end)| > 1 ==> result != start
	ensures |DLLSEG_aVal(start,end)|==1 ==> result==start
//	ensures result == DLLSEG_last_x(start,end,null)
{
	unfolding acc(DLLSEG(start,end),wildcard) in 
		(start.DLLN_next == end) ? start : DLLSEG_last(start.DLLN_next,end)
}
function DLLSEG_prev(start : Ref,end:Ref) : Ref
	requires start!=null
	requires start!=end
	requires acc(DLLSEG(start,end),wildcard)
{
	unfolding acc(DLLSEG(start,end),wildcard) in 
		start.DLLN_prev
}

/////////////////////////////////////////////////////////////////////
//LinkedList
field DLL_head : Ref
field DLL_tail : Ref

predicate DLL(this : Ref)
{
	acc(this.DLL_head) && 
	acc(this.DLL_tail) && 
	(
		(this.DLL_head==null ==> (
			this.DLL_tail == null
		)) &&
		(this.DLL_head!=null ==> (
			acc(DLLSEG(this.DLL_head,null),write) &&
			this.DLL_tail == DLLSEG_last(this.DLL_head,null) &&
//			DLLSEG_prev(this.DLL_head,null) == null
			true
		))
	)
}

function DLL_aVal(this : Ref) : Seq[Int]
	requires this!=null && acc(DLL(this),write)
{
	unfolding acc(DLL(this),write) in 
		((this.DLL_head!=null) ? DLLSEG_aVal(this.DLL_head,null) : Seq[Int]())
}

method DLL_make() returns (r:Ref)
	ensures r!=null
	ensures acc(DLL(r),write)
{
	r := new(DLL_head,DLL_tail)
	r.DLL_head:=null
	r.DLL_tail:=null
	fold DLL(r)
}

method DLL_prepend(this : Ref,x : Int) 
	requires this!=null
	requires acc(DLL(this),write)
	ensures acc(DLL(this),write)
	ensures DLL_aVal(this) == Seq(x) ++ old(DLL_aVal(this))
{
	var n : Ref
	n := new(DLLN_val,DLLN_next,DLLN_prev)
	n.DLLN_val := x
	n.DLLN_prev := null
	
	unfold DLL(this)
	n.DLLN_next := this.DLL_head
	var nn : Ref
	nn := n.DLLN_next
	if (nn!=null)
	{
		unfold acc(DLLSEG(nn,null),write)
		nn.DLLN_prev := n
		fold acc(DLLSEG(nn,null),write)
		assert DLLSEG_last(nn,null)==old(unfolding acc(DLL(this),write) in DLLSEG_last(this.DLL_head,null)) //cannot remove this assertion
		assert old( DLL_aVal(this)) == DLLSEG_aVal(nn,null)
	}else
	{
		this.DLL_tail := n
	}
	fold DLLSEG(n,null)
	this.DLL_head := n
	fold DLL(this)
}

method DLL_append(this : Ref,x : Int)
	requires this!=null
	requires acc(DLL(this),write)
	ensures acc(DLL(this),write)
	ensures DLL_aVal(this) == old(DLL_aVal(this)) ++ Seq(x)
{
	var n : Ref
	n := new(DLLN_val,DLLN_next,DLLN_prev)
	n.DLLN_val := x
	n.DLLN_next := null
	
	unfold DLL(this)
	n.DLLN_prev := this.DLL_tail
	var nn : Ref
	nn := n.DLLN_prev
	if (nn!=null)
	{
		aunfold_DLLSEG_End(this.DLL_head,null,nn)
		unfold acc(DLLSEG(nn,null),write)
		nn.DLLN_next := n
		fold acc(DLLSEG(n,n),write)
		fold acc(DLLSEG(nn,n),write)

		afold_DLLSEG_End(this.DLL_head,nn,n)
		fold acc(DLLSEG(n,null),write)
		afold_DLLSEG_End(this.DLL_head,n,null)
	}else
	{
		this.DLL_head := n
		fold DLLSEG(this.DLL_head,null)
	}
	this.DLL_tail := n
	fold DLL(this)
}

method DLLSEG_last_lemma(start : Ref, end : Ref)
	requires start!=null
	requires start!=end
	requires acc(DLLSEG(start,end),write)
	ensures  acc(DLLSEG(start,end),write)
	ensures DLLSEG_last(start,end)==old(DLLSEG_last(start,end))
	ensures DLLSEG_aVal(start,end)==old(DLLSEG_aVal(start,end))
	ensures DLLSEG_prev(start,end)==old(DLLSEG_prev(start,end))
	ensures |DLLSEG_aVal(start,end)|>1 ==> DLLSEG_last(start,end) != start
{
	unfold acc(DLLSEG(start,end),write)
	if (start.DLLN_next==end)
	{
	}else{
		DLLSEG_last_lemma_x(start.DLLN_next,end,start)
	}
	fold acc(DLLSEG(start,end),write)
}

method DLLSEG_last_lemma_x(start : Ref, end : Ref,x:Ref)	
	requires start!=null
	requires start!=end
	requires acc(DLLSEG(start,end),1/100)
	requires x!=null
	requires acc(x.DLLN_val,write)
	ensures acc(x.DLLN_val,write)
	ensures x.DLLN_val == old(x.DLLN_val)
	ensures acc(DLLSEG(start,end),1/100)
	ensures x != DLLSEG_last(start,end)
	ensures DLLSEG_last(start,end)==old(DLLSEG_last(start,end))
	ensures DLLSEG_aVal(start,end)==old(DLLSEG_aVal(start,end))
	ensures DLLSEG_prev(start,end)==old(DLLSEG_prev(start,end))
{
	unfold acc(DLLSEG(start,end),1/100)
	if (start.DLLN_next==end)
	{
		assert start!=x
		fold acc(DLLSEG(start,end),1/100)
		assert x!=DLLSEG_last(start,end)
	}else{
		DLLSEG_last_lemma_x(start.DLLN_next,end,x)
		fold acc(DLLSEG(start,end),1/100)
	}
	assert x!=DLLSEG_last(start,end)
}

//ghost
method aunfold_DLLSEG_End(start : Ref,end : Ref, p:Ref)
	requires start!=null
	requires start!=end
	requires acc(DLLSEG(start,end),write)
	requires p == DLLSEG_last(start,end)
	ensures acc(DLLSEG(start,p),write)
	ensures acc(DLLSEG(p,end),write)
	ensures start!=p ==> DLLSEG_aVal(start, p) == old(DLLSEG_aVal(start,end)[..|DLLSEG_aVal(start,end)|-1])
	ensures DLLSEG_aVal(p,end)    == old(DLLSEG_aVal(start,end)[|DLLSEG_aVal(start,end)|-1..])
	ensures DLLSEG_last(p,end) == p
	ensures start!=p ==> DLLSEG_prev(start, p) == old(DLLSEG_prev(start,end))
	ensures start==p ==> DLLSEG_prev(p,end) == old(DLLSEG_prev(start,end))
//	ensures start!=old(DLLSEG_last(start,end)) ==> ( DLLSEG_prev(start, old(DLLSEG_last(start,end))) == old(DLLSEG_prev(start,end)) )
{
	DLLSEG_last_lemma(start,end)
	unfold acc(DLLSEG(start,end),write)
	if (start.DLLN_next==end)
	{
		fold acc(DLLSEG(start,end),write)
		fold acc(DLLSEG(start,start),write)
	}else{
		aunfold_DLLSEG_End(start.DLLN_next,end,p)
		fold acc(DLLSEG(start,p),write)
	}
}

//ghost
method afold_DLLSEG_End(start : Ref,middle : Ref, end:Ref)
	requires start!=null
	requires middle!=null
//	requires start!=middle
	requires middle!=end
	
	requires acc(DLLSEG(start,middle),write)
	requires acc(DLLSEG(middle,end),write)
	
	ensures acc(DLLSEG(start,end),write)
	ensures DLLSEG_aVal(start,end) == old(DLLSEG_aVal(start,middle) ++ DLLSEG_aVal(middle,end))
	ensures DLLSEG_last(start,end) == old(DLLSEG_last(middle,end))
{
	if (start==middle)
	{
	}else{
		var l : Ref
		l := DLLSEG_last(start,middle)
		aunfold(start,middle,l)
		unfold DLLSEG(middle,end)
		var n : Ref
		n := middle.next
		
//		assume false;
//			aunfold_DLLSEG_End
//		DLLSEG_last(start,end)
			assert acc(DLLSEG(middle.DLLN_next,end),write);
//			afold
		//	assume false;
	}
}



//===========================================================================

function DLL_aNodes(this : Ref) : Seq[Ref]
	requires this!=null && acc(DLL(this),write)
{
	unfolding acc(DLL(this),write) in 
		((this.DLL_head!=null) ? DLLSEG_aNodes(this.DLL_head,null) : Seq[Ref]())
}

function DLLSEG_aNodes(start : Ref,end:Ref) : Seq[Ref]
	requires start!=null 
	requires acc(DLLSEG(start,end),wildcard)
	ensures start!=end ==> |result|>0
	ensures start==end ==> result == Seq[Ref]()
{
	(start == end) ? Seq[Ref]() :
	unfolding acc(DLLSEG(start,end),wildcard) in 
		Seq(start) ++ ( (start.DLLN_next == null ) ?  Seq[Ref]() :  DLLSEG_aNodes(start.DLLN_next,end) )
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//Leftovers

/*
function DLLSEG_last_x(start : Ref,end:Ref,x:Ref) : Ref
	requires start!=null
	requires start!=end
	requires acc(DLLSEG(start,end),write)
	requires x!=null ==> acc(x.DLLN_next,write)
//	ensures acc(x.DLLN_val,write) //70/100)
//	ensures x.DLLN_val==old(x.DLLN_val)
//	ensures result != null
//	ensures result == DLLSEG_last(start,end)
	ensures x!=null ==> result != x

//	ensures |DLLSEG_aVal(start,end)| > 1 ==> result != x
//	ensures |DLLSEG_aVal(start,end)|==1 ==> result==x
{
	unfolding acc(DLLSEG(start,end),write) in 
		(start.DLLN_next == end) ? start : DLLSEG_last_x(start.DLLN_next,end,x)
}
*/
