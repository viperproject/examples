// ListIterator fields
field iteratee: Ref
field current: Ref
field last: Ref
// List fields
field sentinel: Ref
// Node fields
field next: Ref
field prev: Ref
field val: Int
define NODE_FIELDS(x) acc(x.next) && acc(x.prev) && acc(x.val)
// Node class
predicate state(n: Ref) {
  NODE_FIELDS(n) && (n.next != null ==> acc(state(n.next)) && get_prev(n.next) == n)
}

function get_prev(n: Ref) : Ref
  requires acc(state(n))
  {
    unfolding state(n) in n.prev
  }

// List class
predicate list(l: Ref) {
  acc(l.sentinel) && acc(state(l.sentinel))
}

// ListIterator class
predicate ready(i:Ref) {
  acc(i.iteratee,2/3) && acc(i.iteratee.sentinel) && acc(i.current) && NODE_FIELDS(i.current) && acc(i.last) &&
  (i.current.next != null ==> acc(state(i.current.next)) && get_prev(i.current.next) == i.current) && (let cur == (i.current) in let sent == (i.iteratee.sentinel) in (acc(state(cur)) --* acc(state(sent))))
}

predicate readyForNext(i:Ref) {
  acc(i.iteratee,1/2) && acc(i.iteratee.sentinel) && acc(i.current) && NODE_FIELDS(i.current) && acc(i.last) &&
  i.current.next != null &&acc(state(i.current.next)) && (let cur == (i.current) in let sent == (i.iteratee.sentinel) in (acc(state(cur)) --* acc(state(sent))))
}

predicate readyForRemove(i:Ref) {
  acc(i.iteratee,1/2) && acc(i.iteratee.sentinel) && acc(i.last) && NODE_FIELDS(i.last) && acc(i.current) && (i.current != null ==> NODE_FIELDS(i.current) && i.current.prev == i.last &&
  (i.current.next != null ==> acc(state(i.current.next)))) && (let lst == (i.last) in let sent == (i.iteratee.sentinel) in (acc(state(lst)) --* acc(state(sent))))
}

method ListIterator_hasNext(this : Ref) returns (res : Bool) 
  requires acc(ready(this))
  ensures res ==> acc(readyForNext(this))
  ensures !res ==> acc(ready(this))
{
  unfold ready(this)
  if (this.current.next == null) {
    fold ready(this)
    res := false
  } else {
    fold readyForNext(this)
    res := true
  }
}

method ListIterator_new(l : Ref) returns (this : Ref)
  requires l != null && acc(list(l))
  ensures acc(ready(this)) && (acc(ready(this)) --* acc(list(l)))
  {
    var cur : Ref
    var sent : Ref
    this := new(iteratee,current,last) // new ListIterator(l)
    this.iteratee := l
    unfold list(l)
    this.current := l.sentinel
    cur := this.current
    sent := this.iteratee.sentinel 
    package (acc(state(cur)) --* acc(state(sent)))
    unfold state(l.sentinel)
    fold ready(this)

    package (acc(this.iteratee,1/3) --* acc(this.iteratee,2/3) && l == this.iteratee) // this is a trick - this extra wand is used as a witness for the immutability of this.iteratee (in particular, so that we can assume that it has the same value in the hypothetical package state below, by applying it).
    wand w := (acc(this.iteratee,1/3) --* acc(this.iteratee,2/3) && l == this.iteratee)
 
    package (acc(ready(this)) --* unfolding ready(this) in folding state(this.current) in let cr == (this.current) in let st == (this.iteratee.sentinel) in applying (acc(state(cr)) --* acc(state(st))) in folding acc(list(this.iteratee)) in applying w in acc(list(l)))
  }
