/* TODO
   - try this version in Carbon and check how many of the assertions and assumptions can be removed
   - finish the QP version
*/

predicate aseg(a: Array, from: Int, to: Int) {
  0 <= from && from <= to && to <= length(a) &&
  (from < to  ==> acc(loc(a,from).val) && acc(aseg(a, from+1, to)))
}

method asegMerge(a: Array, from: Int, middle: Int, to: Int)
  requires acc(aseg(a, from, middle));
  requires acc(aseg(a, middle, to));
  ensures  acc(aseg(a, from, to));
  ensures  contents(a, from, to) == old(contents(a, from, middle) ++ contents(a, middle, to));
{
  unfold acc(aseg(a, from, middle));
  if(from < middle) {
    asegMerge(a, from+1, middle, to);
    assert unfolding acc(aseg(a, from+1, to)) in true;
    fold acc(aseg(a, from, to));
  }
}

method asegAppend(a: Array, from: Int, to: Int)
  requires acc(aseg(a, from, to));
  requires acc(loc(a,to).val);
  requires to < length(a);
  ensures  acc(aseg(a, from, to+1));
  ensures  contents(a, from, to+1) == 
           old(contents(a, from, to) ++ Seq(loc(a,to).val));
{
  unfold acc(aseg(a, from, to));
  if(from < to) {
    asegAppend(a, from+1, to);
  } else {
    fold acc(aseg(a, to+1, to+1));
    assert contents(a, from+1, to+1) == Seq[Bool]();  // we seem to need this
  }
  fold acc(aseg(a, from, to+1));
}

method asegFront(a: Array, from: Int, to: Int)
  requires acc(aseg(a, from, to));
  requires from < to;
  ensures  acc(aseg(a, from, to-1));
  ensures  acc(loc(a,to-1).val);
  ensures  contents(a, from, to-1)  ++ Seq(loc(a,to-1).val) == 
           old(contents(a, from, to));

{
  unfold acc(aseg(a, from, to));
  if(from == to-1) {
  } else {
    asegFront(a, from+1, to);
  }
  fold acc(aseg(a, from, to-1));
}



function contentsAll(a: Array): Seq[Bool]
  requires acc(aseg(a, 0, length(a)));
{
  contents(a, 0, length(a))
}


function contents(a: Array, from: Int, to: Int): Seq[Bool]
  requires acc(aseg(a, from, to));
  ensures  |result| == to - from;
{
  from == to ? Seq[Bool]() 
             : unfolding acc(aseg(a, from, to)) in Seq(loc(a,from).val) ++ contents(a, from+1, to)
}

function countFalse(s: Seq[Bool]): Int {
  |s| == 0 ? 0 : ((s[0] ? 0 : 1) + countFalse(s[1..]))
}

method countDistr(s1: Seq[Bool], s2: Seq[Bool])
  ensures countFalse(s1 ++ s2) == countFalse(s1) + countFalse(s2);
{
  if(|s1| == 0) {
    // Silicon needs the following:
    assert s1 ++ s2 == s2;
  } else {
    countDistr(s1[1..], s2);

    // Silicon needs the following:
    assert (s1++s2)[1..] == (s1[1..]++s2);
  }
}

method allFalse(s: Seq[Bool])
  requires forall z: Int :: 0 <= z && z < |s| ==> !s[z];
  ensures  countFalse(s) == |s|;
{
  if(|s| == 0) {
  } else {
    allFalse(s[1..]);
  }
}

method allTrue(s: Seq[Bool])
  requires forall z: Int :: 0 <= z && z < |s| ==> s[z];
  ensures  countFalse(s) == 0;
{
  if(|s| == 0) {
  } else {
    allTrue(s[1..]);
  }
}



method swap(a: Array, i: Int, j: Int)
  requires acc(loc(a,i).val) && acc(loc(a,j).val);
  ensures acc(loc(a,i).val) && acc(loc(a,j).val);
  ensures loc(a,i).val == old(loc(a,j).val);
  ensures loc(a,j).val == old(loc(a,i).val);
{
  var t: Bool;
  t := loc(a,i).val;
  loc(a,i).val := loc(a,j).val;
  loc(a,j).val := t
}

method two_way_sort(a: Array) 
  requires acc(aseg(a, 0, length(a)));
  ensures  acc(aseg(a, 0, length(a)));
  ensures  forall y: Int :: (0 <= y && y < length(a) ==> 
             forall z: Int :: (y < z && z < length(a) ==> 
               !contentsAll(a)[y] || contentsAll(a)[z]));

  ensures countFalse(contents(a,0,length(a))) == old(countFalse(contents(a,0,length(a))));
{
  var measure: Int;     // encode termination
  var i: Int
  i := 0;
  var j : Int;
  j := length(a) - 1;
  fold acc(aseg(a, 0, 0));
  fold acc(aseg(a, length(a), length(a)));
  while (i <= j)
    invariant 0 <= i && i <= j + 1 && j < length(a);
    invariant acc(aseg(a, 0, i)) && acc(aseg(a, i, j+1)) && acc(aseg(a, j+1, length(a)))
    invariant forall z: Int :: (0 <= z && z < i ==> !contents(a, 0, i)[z]);
    invariant forall z: Int :: (0 <= z && z < length(a)-j-1 ==> contents(a, j+1, length(a))[z]);
    invariant old(countFalse(contents(a,0,length(a)))) == i + countFalse(contents(a,i,j+1));
  {
    measure := j - i;
    assert 0 <= measure;  // measure is a natural number

    unfold acc(aseg(a, i, j+1));

    // The following assertion is needed
    assert (Seq(loc(a,i).val) ++ contents(a, i+1, j+1))[1..] == contents(a, i+1, j+1);

    if (!loc(a,i).val) {
      asegAppend(a, 0, i);
      i := i+1;
    } else {
      fold acc(aseg(a, i, j+1));
      // The following assertion is needed. It just repeats the def. of contents
      assert contents(a, i, j+1)[0];

      asegFront(a, i, j+1);

      // Silicon needs the folowing two lines:
      countDistr(contents(a,i,j), Seq(loc(a,j).val));
      assert countFalse(Seq(loc(a,j).val)) == (Seq(loc(a,j).val)[0] ? 0 : 1) + countFalse(Seq(loc(a,j).val)[1..]);

      if (loc(a,j).val) {
        fold acc(aseg(a, j, length(a)));
        // The following assertion is needed. It just repeats the def. of contents
        assert contents(a, j, length(a)) == unfolding acc(aseg(a, j, length(a))) in Seq(loc(a,j).val) ++ contents(a, j+1, length(a));

        j := j-1;

      } else {

        unfold acc(aseg(a, i, j));

        // The following assertion is needed
        assert (Seq(loc(a,i).val) ++ contents(a,i+1,j))[1..] == contents(a,i+1,j);

        // we know that a[i] == true and a[j] == false
        assume i != j;  // Silicon does not derive a[i] != a[j] ==> i != j
        swap(a, i, j);

        asegAppend(a, 0, i);
        fold acc(aseg(a, j, length(a)));

        // The following assertion is needed. It just repeats the def. of contents
        assert contents(a, j, length(a)) == unfolding acc(aseg(a, j, length(a))) in Seq(loc(a,j).val) ++ contents(a, j+1, length(a));
  
        i := i+1;
        j := j-1;
     }
    }

    assert j - i < measure;  // check termination measure
  }

  // It might be nice to add the properties proved by these lemmas to the loop invariant,
  // but that did not go through easily, so I used lemma methods instead
  allFalse(contents(a, 0, i));  // lemma method
  allTrue(contents(a, j+1, length(a)));  // lemma method


  countDistr(contents(a, 0, i), contents(a, i, j+1));  // lemma method
  asegMerge(a, 0, i, j+1);

  countDistr(contents(a, 0, j+1), contents(a, j+1, length(a)));  // lemma method
  asegMerge(a, 0, j+1, length(a));
}


field val: Bool;

domain Array {
  function loc(a: Array, i: Int): Ref
  function length(a: Array): Int
  
  axiom all_diff {
    forall a1: Array, a2: Array, i: Int, j: Int :: {loc(a1, i), loc(a2, j)}
      (a1 != a2 || i != j) ==> loc(a1, i) != loc(a2, j)
  }
  
  axiom length_nonneg {
    forall a: Array :: length(a) >= 0
  }
}
