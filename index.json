{
  "Viper Examples": {
		"description" : "This webpage showcases several interesting examples that demonstrate features of the <a href=\"http://www.pm.inf.ethz.ch/research/viper.html\">Viper verification infrastructure</a>",
		"isCategory" : true
	},

  
  
  

  "binary-search/binary-search-array" : {
    "name": "Binary Search (Quantified Permissions)",
    "description": "Binary search in a sorted (mutable) array",
    "category": "Viper Examples"
  },
  
  "binary-search/binary-search-seq" : {
    "name": "Binary Search (Seq)",
    "description": "Binary search in a sorted (mathematical) sequence",
    "category": "Viper Examples"
  },

  "dutch-flag/dutch-flag" : {
    "name": "Dutch Flag (Quantified Permissions)",
    "description": "Dutch Flag algorithm for coarse sorting of an array",
    "category": "Viper Examples"
  },

  "graph-copy/graph-copy" : {
    "name": "Graph Copy (Quantified Permissions)",
    "description": "Duplicating a heap-allocated (mutable) graph",
    "category": "Viper Examples"
  },

  "graph-marking/graph-marking" : {
    "name": "Graph Marking (Quantified Permissions)",
    "description": "A graph marking algorithm (in the spirit of mark-and-sweep garbage collectors). Note that the example is supposed to yield 1 verification error (the encoding of a false reachability check).",
    "category": "Viper Examples"
  },

  "max_array/max-array-elimination" : {
    "name": "Array Max, by elimination (Quantified Permissions)",
    "description": "Finding the maximum in an array by elimination (COST IC0701 Verification Competition 2011)",
    "category": "Viper Examples"
  },

  "max_array/max-array-standard" : {
    "name": "Array Max, straight-forward (Quantified Permissions)",
    "description": "Finding the maximum in an array the straight-forward way",
    "category": "Viper Examples"
  },
  
  "quickselect/arrays_quickselect_rec" : {
    "name": "Quickselect (Quantified Permissions)",
    "description": "An encoding of the Quickselect algorithm over arrays",
    "category": "Viper Examples"
  },
    
  "tree-delete-min/tree_delete_min" : {
    "name": "Iterative Tree Delete (Magic Wands)",
    "description": "Deletion of minimal tree element (VerifyThis@FM2012)",
    "category": "Viper Examples",
    "excludedVerifiers": ["carbon", "carbon-nightly"]
  },
  
  "parallel-array-replace/parallel-array-replace" : {
    "name": "Parallel Array Replace (Quantified Permissions)",
    "description": "Running example from the CAV'16 paper: replace each occurrence of an element in an array segment by recursing over the two half-segments in parallel.",
    "category": "Viper Examples"
  },
  
  "longest-common-prefix/longest-common-prefix" : {
    "name": "Longest Common Prefix (Quantified Permissions)",
    "description": "Challenge from the VerifyThis Verification Competition 2012: finding the longest common prefix in an array.",
    "category": "Viper Examples"
  },
  
	"vmcai2016/sorted-list-immutable-sequence": {
		"name": "Sorted List",
		"description": "A sorted list of integers, implemented via immutable sequences, and a method that inserts an element into the list.",
		"category": "Viper Examples"
	},
  
	"vmcai2016/guarded-by-monitor-invariant": {
		"name": "Guarded-by Monitor Invariant",
		"description": "A client of a sorted list that acquires a monitor (lock) before changing the list. The first monitor invariant requires the list to be sorted; the second is a two-state invariant and requires the changed flag to be set whenever a thread changes the content of the list between acquiring and releasing the monitor.",
		"category": "Viper Examples"
	},
  
  "vmcai2016/linked-list-predicates": {
		"name": "Linked-List (Predicates)",
		"description": "Inserting into an ordered linked-list which is specified via a recursively-defined predicate. The loop invariant uses a recursively-defined list segment predicate to bookkeep permissions.",
		"category": "Viper Examples"
	},

    "list-iterator/list-iterator": {
      "name": "List Iterator (Magic Wands)",
      "description": "An iterator protocol, for iterating over a linked list. The protocol has 3 states and some state-transitions are encoded using magic wands. Note: this example uses a feature which is currently only supported by the default verifier.",
      "category": "Viper Examples",
      "excludedVerifiers": ["carbon", "carbon-nightly"]
    },

	"vmcai2016/arraylist-quantified-permissions": {
		"name": "Array-List (Quantified Permissions)",
		"description": "Inserting into an array-list which is specified via quantified permissions (iterating separating conjunction).",
		"category": "Viper Examples"
	},

	"vmcai2016/encoding-adts": {
		"name": "Encoding ADTs",
		"description": "An encoding of a Haskell-style Nil-Cons-list, alongside proofs of certain properties of the encoded abstract data type, and a pattern match exhaustiveness check. Note that the example is supposed to yield 1 verification error (the encoding of a failed exhaustiveness check).",
		"category": "Viper Examples"
	},
	
	"blank-example" : {
	    "name": "Empty Example (try your own!)",
	    "description": "Input and verify a new example of your own",
	    "category": "Viper Examples"
	  }
  
}
