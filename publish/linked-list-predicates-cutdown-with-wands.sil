function prio(this: Ref): Int

/*****************************************************************
 * List Nodes
 *****************************************************************/

field data: Int
field next: Ref

predicate lseg(this: Ref, end: Ref)
{
  this != end ==>
	acc(this.data) && acc(this.next) && acc(lseg(this.next, end))
}



/*****************************************************************
 * Lists
 *****************************************************************/

field head: Ref

predicate List(this: Ref)
{
  acc(this.head) && acc(lseg(this.head, null))
}

method concat(this: Ref, ptr: Ref, end: Ref)
  requires acc(lseg(this, ptr))
  requires acc(lseg(ptr, end))
  requires end != null ==> acc(end.next, 1/2) // not creating a cycle
  ensures  acc(lseg(this, end))
  ensures end != null ==> acc(end.next, 1/2)
{
	if(this != ptr)
	{
		unfold acc(lseg(this, ptr))
		concat(this.next, ptr, end)
		fold acc(lseg(this, end))
  }
}

method insert(this: Ref, elem: Int) returns (idx: Int)
  requires acc(List(this))
  ensures  acc(List(this))
{
	var tmp: Ref
  idx := 0

	unfold acc(List(this))

  if(this.head != null)
  {
  	unfold acc(lseg(this.head, null))
  }
  if(this.head == null || elem <= this.head.data)
  {
    tmp := new(data,next)
	  tmp.data := elem
	  tmp.next := this.head
  	fold acc(lseg(this.head, null))
  	fold acc(lseg(tmp, null))
  	this.head := tmp
  }
  else
  {
    var hd : Ref := this.head
    var ptr: Ref := hd
    fold acc(lseg(hd, hd))
  	idx := idx + 1

    while(ptr.next != null &&
        unfolding acc(lseg(ptr.next, null)) in ptr.next.data < elem)
      invariant acc(lseg(ptr, null)) --* acc(lseg(hd, null))
   	  invariant acc(ptr.next) && acc(ptr.data)
   	  invariant acc(lseg(ptr.next, null))
    {
      unfold acc(lseg(ptr.next, null))
      idx := idx + 1;  var last: Ref := ptr
      ptr := ptr.next
    }
     ... // allocate new node at ptr.next, fold predicates
    tmp := new(data,next)
    tmp.data := elem
    tmp.next := ptr.next
    ptr.next := tmp
    fold acc(lseg(ptr.next, null));  fold acc(lseg(ptr, null))
    apply acc(lseg(ptr, null)) --* acc(lseg(hd, null)) // full list  $\label{wand-obtain-list}$
  }
  fold acc(List(this))
}